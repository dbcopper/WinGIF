你是资深 Windows 桌面开发工程师（Rust + Win32 + WinRT + D3D11），请为我生成一个 Windows-only 的轻量录屏转 GIF 工具的完整可编译仓库，并给出构建/运行步骤。重点：按下录制按钮后进入“静止截图式选区模式”，用户鼠标框选区域或点选窗口，确认后开始录制。同时必须实现 overlay 信息显示与主面板 hide/show 行为。**所有的操作都在 cmd 里执行（包括安装依赖、构建、运行、打包等），并且你的所有回复都必须用中文。**# 目标产品形态（UI）- 只有一个横向小窗主面板（520x72 左右）：  1) Record/Stop（同一按钮切换）  2) Export（停止录制后可用）  3) Format 选择（至少实现 GIF；可选 MP4 / PNG Sequence）  4) 状态行：当前模式（Idle/Selecting/Recording/Recorded/Exporting）、录制时长、目标（窗口标题或区域尺寸）- 主面板支持最小化到托盘 tray icon：  - 关闭(X)默认隐藏到托盘，不退出  - 托盘菜单：Show/Hide、Start/Stop、Export last、Quit  - 左键点托盘图标：切换显示/隐藏主面板# 核心交互：像“微信截图/系统截图”的选区模式（关键要求）当用户点击 Record（开始录制）时，不要立刻录屏，而是：0) 进入 Selecting 之前，必须执行：主面板 Hide()（避免出现在冻结截图/录制里）1) 截取当前屏幕的静态画面（整个虚拟桌面：多显示器也要覆盖）2) 显示一个全屏（覆盖虚拟桌面）的 Overlay 选区窗口：   - 背景显示第 1 步的静态截图（屏幕“冻结”效果）   - 鼠标十字光标   - 支持两种选择：     A) 框选区域：按下拖动形成矩形，松开完成选择     B) 选窗口：移动鼠标时高亮当前鼠标所在的顶层窗口边框；单击选中该窗口   - 交互细节：     - Esc 取消选区：退出 overlay，恢复显示主面板 Show()，回到 Idle     - Enter 确认当前选区：退出 overlay，然后开始录制；之后主面板 Show()（或保持隐藏也行，但必须有一致策略）     - 鼠标拖动阈值：拖动超过 6px 判定为“区域选择”；否则判定为“窗口选择点击”   - Overlay 顶部/角落必须显示信息（强制）：     - 当前鼠标坐标：X,Y（虚拟桌面坐标，物理像素）     - 当前选择区域尺寸：W x H（无选择时显示 0x0 或 “—”）     - hover 到窗口时显示：窗口标题（GetWindowText），并在 overlay 上高亮该窗口 rect   - Overlay 顶部可显示提示文字：拖拽框选 / 单击选窗口 / Enter 确认 / Esc 取消3) 选定后，Overlay 立即退出（保证不被录进去），可加 80~150ms 延迟4) 开始真正录制目标（区域或窗口）5) Selecting 取消或确认后都必须 Show() 主面板（取消立即恢复；确认在录制开始后恢复或立即恢复均可，但要稳定一致）# 选窗口实现（重要：Overlay 在最上层，不能用 WindowFromPoint 直接点穿）- 不要依赖把 overlay 设成 click-through- 用 Win32 枚举窗口 + Z-order 命中测试实现：  - 从 GetTopWindow(NULL) / GetWindow(GW_HWNDNEXT) 获取 Z-order 列表  - 过滤：IsWindowVisible==true、非 toolwindow、排除自身 overlay、排除主面板  - 排除 cloaked（DwmGetWindowAttribute DWMWA_CLOAKED）  - 取 GetWindowRect 的屏幕坐标（在 Per-monitor DPI aware v2 下是物理像素）  - 鼠标位置在某 rect 内：选择 Z-order 最靠前的那个作为 hover window  - hover window：    - overlay 高亮边框    - 显示窗口标题（GetWindowText）在信息栏  - 单击时确认该 HWND 为录制目标# 选区域实现（跨显示器）- Overlay 覆盖虚拟桌面（SM_XVIRTUALSCREEN / SM_YVIRTUALSCREEN / SM_CXVIRTUALSCREEN / SM_CYVIRTUALSCREEN）- 区域选择返回一个屏幕坐标系（虚拟桌面物理像素）的矩形 rect- 录制阶段：  - MVP 允许区域跨多显示器，但实现上要靠谱：    方案 1（推荐简单可用）：选择“包含区域中心点”的那块显示器作为 capture source；      - 如果区域跨屏，则提示用户“跨屏区域将以主显示器为准裁剪（或选择覆盖面积最大的显示器）”    方案 2（加分）：支持跨屏，分别捕捉每个 monitor，再在导出阶段拼接  - 请至少实现方案 1，并把跨屏处理写清楚（提示/限制/策略）# 捕捉技术路线（Windows Graphics Capture 为主）- 使用 Windows.Graphics.Capture (WGC)- 通过 Win32 interop 创建 capture item：  - IGraphicsCaptureItemInterop::CreateForWindow(HWND) 用于窗口  - IGraphicsCaptureItemInterop::CreateForMonitor(HMONITOR) 用于显示器- 创建 D3D11 device + Direct3D11CaptureFramePool::CreateFreeThreaded（避免 DispatcherQueue）- session.StartCapture() 开始# 自动尺寸变化（窗口录制必须跟随）- 对窗口录制：每帧读取 frame.ContentSize()，若变化：  - frame_pool.Recreate(device, format, frame_count, new_size)  - 下游编码/帧保存逻辑要适配新尺寸- 对区域录制：区域 rect 固定，但 source（monitor）尺寸可能变；同样按 ContentSize 处理- 由于 GIF/视频通常需要固定分辨率：  - 录制阶段允许保存“原始尺寸帧”  - 导出阶段统一缩放/letterbox 到固定宽度（用户选择预设：480/720/原始）# 录制与导出策略（务实稳定）- 录制阶段不要直接写 GIF- 录制阶段保存帧：  - 推荐落盘 PNG 序列到 %TEMP%/myrec-<uuid>/  - 帧命名 frame_000001.png ...  - 默认 FPS 录制 30（或采样为 20），导出时可选 15/20/30- 停止录制后 Export 执行：  - GIF：用 gifski（Rust crate）将 PNG 序列合成为 GIF（提供 FPS & width presets）  - PNG Sequence：拷贝到用户选择目录  - MP4 可选：若检测到 ffmpeg 可用则支持（不是必须）- Export 使用保存对话框（rfd crate）- 导出过程中 UI 要显示进度/状态，不阻塞界面# 多线程架构（必须）- UI 线程只做交互与状态显示- Selection overlay 单独模块（可以在 UI 线程创建，但捕捉与写盘必须在 worker）- capture worker：  - 接收“StartCapture(Target)”命令（Target=Window(HWND) 或 Region{monitor,rect}）  - 将帧写 PNG（后台线程）  - 通过 channel 回传：时长、帧数、错误、当前目标信息- export worker：  - gifski 合成在后台线程  - 完成后通知 UI# DPI / 坐标必须正确（必须）- 程序设置为 Per-monitor DPI aware v2（SetProcessDpiAwarenessContext）- 所有 rect 采用“物理像素”的屏幕坐标- Overlay 使用虚拟桌面坐标，并正确显示截图背景与选框/窗口高亮# 工程交付物（必须）输出完整仓库结构，例如：- Cargo.toml（workspace）- crates/  - app/          (主程序：主面板 UI + tray + 状态机)  - overlay/      (静态截图 + 选区/选窗口 overlay + 信息栏显示)  - capture_wgc/  (WGC 捕捉：CreateForWindow/CreateForMonitor + framepool + resize + crop)  - export/       (gifski 导出、png 导出、可选 ffmpeg)- assets/icon.ico （tray & window icon）- README.md：Windows 版本要求、如何运行、常见问题（权限/DPI/跨屏策略）。**README 中所有命令示例必须是 cmd（不是 PowerShell/WSL），例如用 `set`、`where`、`mkdir`、`rmdir` 等。**# 关键实现细节（必须做到）1) Overlay 的“冻结效果”：   - 进入 Selecting 状态时先抓取虚拟桌面截图（GDI BitBlt 或 DXGI duplication 均可；请选实现更简单可靠的一种）   - Overlay 显示该截图为背景，并绘制半透明遮罩与选框/窗口高亮2) 选窗口命中测试必须基于 Z-order 枚举，而不是 WindowFromPoint（因为 overlay 覆盖）3) 录制开始前必须关闭 overlay，避免录进去（可加 100ms delay）4) 区域录制的 crop：对 monitor capture frame 做 GPU crop（CopySubresourceRegion 到目标纹理），再 map/编码5) 状态机：Idle → Selecting → Recording → Recorded → Exporting，Esc/Enter 行为完整6) Selecting 前必须 Hide() 主面板；Selecting 取消或确认后必须 Show() 主面板（取消立即恢复）7) Overlay 信息栏必须显示：鼠标坐标 X,Y；当前选区 W x H；hover 窗口标题（hover 时）8) 任何失败要在主面板显示可读错误（例如：创建 capture item 失败、导出失败）# 输出格式- 先简短说明总体架构与关键模块- 然后逐文件输出完整代码（不要省略，不要 TODO）- 最后给构建运行步骤和使用说明（如何选区/选窗口/导出），并强调所有操作在 cmd 中执行现在开始生成完整代码仓库。